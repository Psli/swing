{"version":3,"sources":["card.js"],"names":[],"mappings":"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","file":"card.js","sourcesContent":["import _ from 'lodash';\nimport Sister from 'sister';\nimport Hammer from 'hammerjs';\nimport rebound from 'rebound';\nimport vendorPrefix from 'vendor-prefix';\nimport raf from 'raf';\n\nimport Direction from './direction.enum'\nimport {\n    elementChildren,\n    isTouchDevice\n} from './util';\n\n/**\n * @param {Stack} stack\n * @param {HTMLElement} targetElement\n * @return {Object} An instance of Card.\n */\nconst Card = (stack, targetElement) => {\n    let card,\n        config,\n        currentX,\n        currentY,\n        doMove,\n        eventEmitter,\n        isDraging,\n        lastThrow,\n        lastTranslate,\n        lastX,\n        lastY,\n        mc,\n        onSpringUpdate,\n        springSystem,\n        springThrowIn,\n        springThrowOut,\n        throwOutDistance,\n        throwWhere,\n        throwDirectionToEventName;\n\n    const construct = () => {\n        card = {};\n        config = Card.makeConfig(stack.getConfig());\n        eventEmitter = Sister();\n        springSystem = stack.getSpringSystem();\n        springThrowIn = springSystem.createSpring(250, 10);\n        springThrowOut = springSystem.createSpring(500, 20);\n        lastThrow = {};\n        lastTranslate = {\n            x: 0,\n            y: 0\n        };\n\n        /* Mapping directions to event names */\n        throwDirectionToEventName = {};\n        throwDirectionToEventName[Direction.LEFT] = 'throwoutleft';\n        throwDirectionToEventName[Direction.RIGHT] = 'throwoutright';\n        throwDirectionToEventName[Direction.UP] = 'throwoutup';\n        throwDirectionToEventName[Direction.DOWN] = 'throwoutdown';\n\n        springThrowIn.setRestSpeedThreshold(0.05);\n        springThrowIn.setRestDisplacementThreshold(0.05);\n\n        springThrowOut.setRestSpeedThreshold(0.05);\n        springThrowOut.setRestDisplacementThreshold(0.05);\n\n        throwOutDistance = config.throwOutDistance(config.minThrowOutDistance, config.maxThrowOutDistance);\n\n        mc = new Hammer.Manager(targetElement, {\n            recognizers: [\n                [\n                    Hammer.Pan,\n                    {\n                        threshold: 2\n                    }\n                ]\n            ]\n        });\n\n        Card.appendToParent(targetElement);\n\n        eventEmitter.on('panstart', () => {\n            Card.appendToParent(targetElement);\n\n            eventEmitter.trigger('dragstart', {\n                target: targetElement\n            });\n\n            currentX = 0;\n            currentY = 0;\n\n            isDraging = true;\n\n            (function animation () {\n                if (isDraging) {\n                    doMove();\n\n                    raf(animation);\n                }\n            })();\n        });\n\n        eventEmitter.on('panmove', (e) => {\n            currentX = e.deltaX;\n            currentY = e.deltaY;\n        });\n\n        eventEmitter.on('panend', (e) => {\n            isDraging = false;\n\n            const x = lastTranslate.x + e.deltaX;\n            const y = lastTranslate.y + e.deltaY;\n\n            let isThrowOut = config.isThrowOut(\n                x,\n                y,\n                targetElement,\n                config.throwOutConfidence(x, y, targetElement)\n            );\n\n            /* Not really sure about computing direction here and filtering on directions here */\n            /* It adds more logic. Any suggestion will be apreciated */\n            let direction = computeDirection(x, y, config.allowedDirections);\n\n            if (isThrowOut && direction !== Direction.INVALID) {\n                card.throwOut(x, y, direction);\n            } else {\n                card.throwIn(x, y, direction);\n            }\n\n            eventEmitter.trigger('dragend', {\n                target: targetElement\n            });\n        });\n\n        // \"mousedown\" event fires late on touch enabled devices, thus listening\n        // to the touchstart event for touch enabled devices and mousedown otherwise.\n        if (isTouchDevice()) {\n            targetElement.addEventListener('touchstart', () => {\n                eventEmitter.trigger('panstart');\n            });\n\n            // Disable scrolling while dragging the element on the touch enabled devices.\n            // @see http://stackoverflow.com/a/12090055/368691\n            (() => {\n                let dragging;\n\n                targetElement.addEventListener('touchstart', () => {\n                    dragging = true;\n                });\n\n                targetElement.addEventListener('touchend', () => {\n                    dragging = false;\n                });\n\n                global.addEventListener('touchmove', (e) => {\n                    if (dragging) {\n                        e.preventDefault();\n                    }\n                });\n            })();\n        } else {\n            targetElement.addEventListener('mousedown', () => {\n                eventEmitter.trigger('panstart');\n            });\n        }\n\n        mc.on('panmove', (e) => {\n            eventEmitter.trigger('panmove', e);\n        });\n\n        mc.on('panend', (e) => {\n            eventEmitter.trigger('panend', e);\n        });\n\n        springThrowIn.addListener({\n            onSpringUpdate: (spring) => {\n                const value = spring.getCurrentValue();\n                const x = rebound.MathUtil.mapValueInRange(value, 0, 1, lastThrow.fromX, 0);\n                const y = rebound.MathUtil.mapValueInRange(value, 0, 1, lastThrow.fromY, 0);\n\n                onSpringUpdate(x, y);\n            },\n            onSpringAtRest: () => {\n                eventEmitter.trigger('throwinend', {\n                    target: targetElement\n                });\n            }\n        });\n\n        springThrowOut.addListener({\n            onSpringUpdate: (spring) => {\n\n                const value = spring.getCurrentValue();\n\n                var x, y, directionFactor;\n\n\n                if (lastThrow.direction === Direction.RIGHT || lastThrow.direction === Direction.LEFT) {\n                    directionFactor = lastThrow.direction === Direction.RIGHT ? 1 : -1;\n                    x = rebound.MathUtil.mapValueInRange(value, 0, 1, lastThrow.fromX, throwOutDistance * directionFactor);\n                    y = lastThrow.fromY;\n                } else if (lastThrow.direction === Direction.UP || lastThrow.direction === Direction.DOWN) {\n                    directionFactor = lastThrow.direction === Direction.DOWN ? 1 : -1;\n                    x = lastThrow.fromX;\n                    y = rebound.MathUtil.mapValueInRange(value, 0, 1, lastThrow.fromY, throwOutDistance * directionFactor);\n                }\n\n                onSpringUpdate(x, y);\n            },\n            onSpringAtRest: () => {\n                eventEmitter.trigger('throwoutend', {\n                    target: targetElement\n                });\n            }\n        });\n\n        /**\n         * Transforms card position based on the current environment variables.\n         *\n         * @return {undefined}\n         */\n        doMove = () => {\n            let r,\n                x,\n                y;\n\n            if (currentX === lastX && currentY === lastY) {\n                return;\n            }\n\n            lastX = currentX;\n            lastY = currentY;\n\n            x = lastTranslate.x + currentX;\n            y = lastTranslate.y + currentY;\n            r = config.rotation(x, y, targetElement, config.maxRotation);\n\n            config.transform(targetElement, x, y, r);\n\n            eventEmitter.trigger('dragmove', {\n                target: targetElement,\n                throwOutConfidence: config.throwOutConfidence(x, y, targetElement),\n                throwDirection: computeDirection(x, y, config.allowedDirections),\n                offset: x\n            });\n        };\n\n\n        /**\n         * Invoked every time the physics solver updates the Spring's value.\n         *\n         * @param {Number} x\n         * @param {Number} y\n         * @return {undefined}\n         */\n        onSpringUpdate = (x, y) => {\n            let r;\n\n            r = config.rotation(x, y, targetElement, config.maxRotation);\n\n            lastTranslate.x = x || 0;\n            lastTranslate.y = y || 0;\n\n            Card.transform(targetElement, x, y, r);\n        };\n\n        /**\n         * @param {Card.THROW_IN|Card.THROW_OUT} where\n         * @param {Number} fromX\n         * @param {Number} fromY\n         * @param {Direction} [direction]\n         * @return {undefined}\n         */\n        throwWhere = (where, fromX, fromY, direction) => {\n            lastThrow.fromX = fromX;\n            lastThrow.fromY = fromY;\n            /* If direction argument is not set, compute it from coordinates */\n            lastThrow.direction = direction || computeDirection(fromX, fromY, config.allowedDirections);\n\n            if (where === Card.THROW_IN) {\n                springThrowIn.setCurrentValue(0).setAtRest().setEndValue(1);\n\n                eventEmitter.trigger('throwin', {\n                    target: targetElement,\n                    throwDirection: lastThrow.direction\n                });\n            } else if (where === Card.THROW_OUT) {\n                springThrowOut.setCurrentValue(0).setAtRest().setVelocity(100).setEndValue(1);\n\n                eventEmitter.trigger('throwout', {\n                    target: targetElement,\n                    throwDirection: lastThrow.direction\n                });\n\n                /* Emits more accurate events about specific directions */\n                eventEmitter.trigger(throwDirectionToEventName[lastThrow.direction], {\n                    target: targetElement,\n                    throwDirection: lastThrow.direction\n                });\n\n            } else {\n                throw new Error('Invalid throw event.');\n            }\n        };\n\n    };\n\n    construct();\n\n    /**\n     * Alias\n     */\n    card.on = eventEmitter.on;\n    card.trigger = eventEmitter.trigger;\n\n    /**\n     * Throws a card into the stack from an arbitrary position.\n     *\n     * @param {Number} fromX\n     * @param {Number} fromY\n     * @param {Direction} [direction]\n     * @return {undefined}\n     */\n    card.throwIn = (x, y, direction) => {\n        throwWhere(Card.THROW_IN, x, y, direction);\n    };\n\n    /**\n     * Throws a card out of the stack in the direction away from the original offset.\n     *\n     * @param {Number} fromX\n     * @param {Number} fromY\n     * @param {Direction} [direction]\n     * @return {undefined}\n     */\n    card.throwOut = (x, y, direction) => {\n        throwWhere(Card.THROW_OUT, x, y, direction);\n    };\n\n    /**\n     * Unbinds all Hammer.Manager events.\n     * Removes the listeners from the physics simulation.\n     *\n     * @return {undefined}\n     */\n    card.destroy = () => {\n        mc.destroy();\n        springThrowIn.destroy();\n        springThrowOut.destroy();\n\n        stack.destroyCard(card);\n    };\n\n    return card;\n};\n\n/**\n * Creates a configuration object.\n *\n * @param {Object} config\n * @return {Object}\n */\nCard.makeConfig = (config = {}) => {\n    const defaultConfig = {\n        isThrowOut: Card.isThrowOut,\n        throwOutConfidence: Card.throwOutConfidence,\n        throwOutDistance: Card.throwOutDistance,\n        minThrowOutDistance: 400,\n        maxThrowOutDistance: 500,\n        rotation: Card.rotation,\n        maxRotation: 20,\n        transform: Card.transform,\n        allowedDirections: [Direction.RIGHT, Direction.LEFT, Direction.UP]\n    };\n\n    return _.assign({}, defaultConfig, config);\n};\n\n/**\n * Uses CSS transform to translate element position and rotation.\n *\n * Invoked in the event of `dragmove` and every time the physics solver is triggered.\n *\n * @param {HTMLElement} element\n * @param {Number} x Horizontal offset from the startDrag.\n * @param {Number} y Vertical offset from the startDrag.\n * @param {Number} r\n * @return {undefined}\n */\nCard.transform = (element, x, y, r) => {\n    element.style[vendorPrefix('transform')] = `translate3d(0, 0, 0) translate(${x}px, ${y}px) rotate(${r}deg)`;\n};\n\n/**\n * Append element to the parentNode.\n *\n * This makes the element first among the siblings. The reason for using\n * this as opposed to zIndex is to allow CSS selector :nth-child.\n *\n * Invoked in the event of mousedown.\n * Invoked when card is added to the stack.\n *\n * @param {HTMLElement} element The target element.\n * @return {undefined}\n */\nCard.appendToParent = (element) => {\n    const parentNode = element.parentNode;\n    const siblings = elementChildren(parentNode);\n    const targetIndex = siblings.indexOf(element);\n\n    if (targetIndex + 1 !== siblings.length) {\n        parentNode.removeChild(element);\n        parentNode.appendChild(element);\n    }\n};\n\n/**\n * Returns a value between 0 and 1 indicating the completeness of the throw out condition.\n *\n * Ration of the absolute distance from the original card position and element width.\n *\n * @param {Number} offset Distance from the dragStart.\n * @param {HTMLElement} element Element.\n * @return {Number}\n */\nCard.throwOutConfidence = (xOffset, yOffset, element) => {\n    var xConfidence = Math.min(Math.abs(xOffset) / element.offsetWidth, 1);\n    var yConfidence = Math.min(Math.abs(yOffset) / element.offsetHeight, 1);\n    return Math.max(xConfidence, yConfidence);\n};\n\n/**\n * Determines if element is being thrown out of the stack.\n *\n * Element is considered to be thrown out when throwOutConfidence is equal to 1.\n *\n * @param {Number} offset Distance from the dragStart.\n * @param {HTMLElement} element Element.\n * @param {Number} throwOutConfidence config.throwOutConfidence\n * @return {Boolean}\n */\nCard.isThrowOut = (xOffset, yOffset, element, throwOutConfidence) => {\n    return throwOutConfidence === 1;\n};\n\n/**\n * Calculates a distances at which the card is thrown out of the stack.\n *\n * @param {Number} min\n * @param {Number} max\n * @return {Number}\n */\nCard.throwOutDistance = (min, max) => {\n    return _.random(min, max);\n};\n\n/**\n * Calculates rotation based on the element x and y offset, element width and maxRotation variables.\n *\n * @param {Number} x Horizontal offset from the startDrag.\n * @param {Number} y Vertical offset from the startDrag.\n * @param {HTMLElement} element Element.\n * @param {Number} maxRotation\n * @return {Number} Rotation angle expressed in degrees.\n */\nCard.rotation = (x, y, element, maxRotation) => {\n    const horizontalOffset = Math.min(Math.max(x / element.offsetWidth, -1), 1);\n    const verticalOffset = (y > 0 ? 1 : -1) * Math.min(Math.abs(y) / 100, 1);\n    const rotation = horizontalOffset * verticalOffset * maxRotation;\n\n    return rotation;\n};\n\n/**\n * @param {Number} fromX\n * @param {Number} fromY\n * @param {Direction[]} allowedDirections\n * @return {Direction[]} computed direction\n */\nlet computeDirection = (fromX, fromY, allowedDirections) => {\n    let direction = Math.abs(fromX) > Math.abs(fromY) ?\n        fromX < 0 ? Direction.LEFT: Direction.RIGHT :\n        fromY < 0 ? Direction.UP : Direction.DOWN;\n\n    /* Returning an invalid direction if not allowed */\n    if (allowedDirections.indexOf(direction) === -1) {\n        return Direction.INVALID;\n    }\n\n    return direction;\n\n}\n\nCard.THROW_IN = 'in';\nCard.THROW_OUT = 'out';\n\nexport default Card;\n"]}